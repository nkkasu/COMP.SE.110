/*
 * Digitraffic Road API
 * [OpenAPI document](/swagger/openapi.json)   Digitraffic is a service operated by the [Fintraffic](https://www.fintraffic.fi) offering real time traffic information. Currently the service covers *road, marine and rail* traffic. More information can be found at the [Digitraffic website](https://www.digitraffic.fi/)   The service has a public Google-group [road.digitraffic.fi](https://groups.google.com/forum/#!forum/roaddigitrafficfi) for communication between developers, service administrators and Fintraffic. The discussion in the forum is mostly in Finnish, but you're welcome to communicate in English too.   ### General notes of the API * Many Digitraffic APIs use GeoJSON as data format. Definition of the GeoJSON format can be found at https://tools.ietf.org/html/rfc7946. * For dates and times [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format is used with \"Zulu\" zero offset from UTC unless otherwise specified (i.e., \"yyyy-mm-ddThh:mm:ss[.mmm]Z\"). E.g. 2019-11-01T06:30:00Z.
 *
 * The version of the OpenAPI document: 2.94.0#e017ffd@2022-10-18T07:48:28+0000
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package fi.tuni.monitor.roadapi.api;

import com.fasterxml.jackson.core.type.TypeReference;

import fi.tuni.monitor.roadapi.ApiException;
import fi.tuni.monitor.roadapi.ApiClient;
import fi.tuni.monitor.roadapi.Configuration;
import fi.tuni.monitor.roadapi.model.*;
import fi.tuni.monitor.roadapi.Pair;

import fi.tuni.monitor.roadapi.model.CameraHistory;
import fi.tuni.monitor.roadapi.model.CameraHistoryChanges;
import fi.tuni.monitor.roadapi.model.CameraHistoryPresences;
import fi.tuni.monitor.roadapi.model.D2LogicalModel;
import fi.tuni.monitor.roadapi.model.Datex2MessageType;
import fi.tuni.monitor.roadapi.model.ForecastSectionWeatherRoot;
import fi.tuni.monitor.roadapi.model.MaintenanceTrackingFeatureCollectionOld;
import fi.tuni.monitor.roadapi.model.MaintenanceTrackingFeatureOld;
import fi.tuni.monitor.roadapi.model.MaintenanceTrackingLatestFeatureCollectionOld;
import fi.tuni.monitor.roadapi.model.MaintenanceTrackingTaskOld;
import java.time.OffsetDateTime;
import fi.tuni.monitor.roadapi.model.TrafficAnnouncementFeatureCollectionOldV2;
import fi.tuni.monitor.roadapi.model.TrafficSignHistory;
import fi.tuni.monitor.roadapi.model.VariableSignFeatureCollection;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DataV2Api {
  private ApiClient apiClient;

  public DataV2Api() {
    this(Configuration.getDefaultApiClient());
  }

  public DataV2Api(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  public ApiClient getApiClient() {
    return apiClient;
  }

  public void setApiClient(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  /**
   * Active Datex2 messages for traffic-incident, roadwork, weight-restriction -types. Will be removed after 2022-11-01
   * 
   * @param datex2MessageType Datex2 Message type. (required)
   * @param inactiveHours Return datex2 messages from given amount of hours in the past. (optional, default to 0)
   * @return D2LogicalModel
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public D2LogicalModel datex2(Datex2MessageType datex2MessageType, Integer inactiveHours) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'datex2MessageType' is set
    if (datex2MessageType == null) {
      throw new ApiException(400, "Missing the required parameter 'datex2MessageType' when calling datex2");
    }
    
    // create path and map variables
    String localVarPath = "/api/v2/data/traffic-datex2/{datex2MessageType}.xml"
      .replaceAll("\\{" + "datex2MessageType" + "\\}", apiClient.escapeString(datex2MessageType.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("inactiveHours", inactiveHours));

    
    
    
    final String[] localVarAccepts = {
      "application/xml;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<D2LogicalModel> localVarReturnType = new TypeReference<D2LogicalModel>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Datex2 messages history by situation id for traffic-incident, roadwork, weight-restriction -types. Will be removed after 2022-11-01
   * 
   * @param datex2MessageType Datex2 Message type. (required)
   * @param situationId Datex2 situation id. (required)
   * @return D2LogicalModel
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public D2LogicalModel datex2BySituationId(Datex2MessageType datex2MessageType, String situationId) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'datex2MessageType' is set
    if (datex2MessageType == null) {
      throw new ApiException(400, "Missing the required parameter 'datex2MessageType' when calling datex2BySituationId");
    }
    
    // verify the required parameter 'situationId' is set
    if (situationId == null) {
      throw new ApiException(400, "Missing the required parameter 'situationId' when calling datex2BySituationId");
    }
    
    // create path and map variables
    String localVarPath = "/api/v2/data/traffic-datex2/{datex2MessageType}/{situationId}.xml"
      .replaceAll("\\{" + "datex2MessageType" + "\\}", apiClient.escapeString(datex2MessageType.toString()))
      .replaceAll("\\{" + "situationId" + "\\}", apiClient.escapeString(situationId.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/xml;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<D2LogicalModel> localVarReturnType = new TypeReference<D2LogicalModel>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Active Datex2 JSON messages for traffic-incident, roadwork, weight-restriction -types. Will be removed after 2022-11-01
   * 
   * @param datex2MessageType Datex2 Message type. (required)
   * @param inactiveHours Return datex2 messages from given amount of hours in the past. (optional, default to 0)
   * @return TrafficAnnouncementFeatureCollectionOldV2
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public TrafficAnnouncementFeatureCollectionOldV2 datex2Json(Datex2MessageType datex2MessageType, Integer inactiveHours) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'datex2MessageType' is set
    if (datex2MessageType == null) {
      throw new ApiException(400, "Missing the required parameter 'datex2MessageType' when calling datex2Json");
    }
    
    // create path and map variables
    String localVarPath = "/api/v2/data/traffic-datex2/{datex2MessageType}.json"
      .replaceAll("\\{" + "datex2MessageType" + "\\}", apiClient.escapeString(datex2MessageType.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("inactiveHours", inactiveHours));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<TrafficAnnouncementFeatureCollectionOldV2> localVarReturnType = new TypeReference<TrafficAnnouncementFeatureCollectionOldV2>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Datex2 JSON messages history by situation id for traffic-incident, roadwork, weight-restriction -types. Will be removed after 2022-11-01
   * 
   * @param datex2MessageType Datex2 Message type. (required)
   * @param situationId Datex2 situation id. (required)
   * @return TrafficAnnouncementFeatureCollectionOldV2
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public TrafficAnnouncementFeatureCollectionOldV2 datex2JsonBySituationId(Datex2MessageType datex2MessageType, String situationId) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'datex2MessageType' is set
    if (datex2MessageType == null) {
      throw new ApiException(400, "Missing the required parameter 'datex2MessageType' when calling datex2JsonBySituationId");
    }
    
    // verify the required parameter 'situationId' is set
    if (situationId == null) {
      throw new ApiException(400, "Missing the required parameter 'situationId' when calling datex2JsonBySituationId");
    }
    
    // create path and map variables
    String localVarPath = "/api/v2/data/traffic-datex2/{datex2MessageType}/{situationId}.json"
      .replaceAll("\\{" + "datex2MessageType" + "\\}", apiClient.escapeString(datex2MessageType.toString()))
      .replaceAll("\\{" + "situationId" + "\\}", apiClient.escapeString(situationId.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<TrafficAnnouncementFeatureCollectionOldV2> localVarReturnType = new TypeReference<TrafficAnnouncementFeatureCollectionOldV2>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Road maintenance tracking data latest points. Will be removed after 2022-11-01
   * 
   * @param from Return trackings which have completed after the given time (inclusive). Default is -1h from now and maximum -24h. (optional)
   * @param xMin Minimum x coordinate (longitude) Coordinates are in WGS84 format in decimal degrees. Values between 19.0 and 32.0. (optional, default to 19)
   * @param yMin Minimum y coordinate (latitude). Coordinates are in WGS84 format in decimal degrees. Values between 59.0 and 72.0. (optional, default to 59)
   * @param xMax Maximum x coordinate (longitude). Coordinates are in WGS84 format in decimal degrees. Values between 19.0 and 32.0. (optional, default to 32)
   * @param yMax Maximum y coordinate (latitude). Coordinates are in WGS84 format in decimal degrees. Values between 59.0 and 72.0. (optional, default to 72)
   * @param taskId Task ids to include. Any tracking containing one of the selected tasks will be returned. (optional
   * @return MaintenanceTrackingLatestFeatureCollectionOld
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public MaintenanceTrackingLatestFeatureCollectionOld findLatestMaintenanceTrackings1(OffsetDateTime from, Double xMin, Double yMin, Double xMax, Double yMax, List<String> taskId) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v2/data/maintenance/trackings/latest";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("from", from));
    localVarQueryParams.addAll(apiClient.parameterToPair("xMin", xMin));
    localVarQueryParams.addAll(apiClient.parameterToPair("yMin", yMin));
    localVarQueryParams.addAll(apiClient.parameterToPair("xMax", xMax));
    localVarQueryParams.addAll(apiClient.parameterToPair("yMax", yMax));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "taskId", taskId));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<MaintenanceTrackingLatestFeatureCollectionOld> localVarReturnType = new TypeReference<MaintenanceTrackingLatestFeatureCollectionOld>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Road maintenance tracking data. Will be removed after 2022-11-01
   * 
   * @param from Return trackings which have completed after the given time (inclusive). Default is 24h in past and maximum interval between from and to is 24h. (optional)
   * @param to Return trackings which have completed before the given time (inclusive). Default is now and maximum interval between from and to is 24h. (optional)
   * @param xMin Minimum x coordinate (longitude) Coordinates are in WGS84 format in decimal degrees. Values between 19.0 and 32.0. (optional, default to 19)
   * @param yMin Minimum y coordinate (latitude). Coordinates are in WGS84 format in decimal degrees. Values between 59.0 and 72.0. (optional, default to 59)
   * @param xMax Maximum x coordinate (longitude). Coordinates are in WGS84 format in decimal degrees. Values between 19.0 and 32.0. (optional, default to 32)
   * @param yMax Maximum y coordinate (latitude). Coordinates are in WGS84 format in decimal degrees. Values between 59.0 and 72.0. (optional, default to 72)
   * @param taskId Task ids to include. Any tracking containing one of the selected tasks will be returned. (optional
   * @return MaintenanceTrackingFeatureCollectionOld
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public MaintenanceTrackingFeatureCollectionOld findMaintenanceTrackings1(OffsetDateTime from, OffsetDateTime to, Double xMin, Double yMin, Double xMax, Double yMax, List<String> taskId) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v2/data/maintenance/trackings";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("from", from));
    localVarQueryParams.addAll(apiClient.parameterToPair("to", to));
    localVarQueryParams.addAll(apiClient.parameterToPair("xMin", xMin));
    localVarQueryParams.addAll(apiClient.parameterToPair("yMin", yMin));
    localVarQueryParams.addAll(apiClient.parameterToPair("xMax", xMax));
    localVarQueryParams.addAll(apiClient.parameterToPair("yMax", yMax));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "taskId", taskId));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<MaintenanceTrackingFeatureCollectionOld> localVarReturnType = new TypeReference<MaintenanceTrackingFeatureCollectionOld>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Weather camera history for given camera or preset
   * 
   * @param id Camera or preset id(s) (required)
   * @param at Return the latest url for the image from the history at the given date time. If the time is not given then the history of last 24h is returned. (optional)
   * @return List&lt;CameraHistory&gt;
   * @throws ApiException if fails to make API call
   */
  public List<CameraHistory> getCameraOrPresetHistory1(List<String> id, OffsetDateTime at) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getCameraOrPresetHistory1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v2/data/camera-history/history";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "id", id));
    localVarQueryParams.addAll(apiClient.parameterToPair("at", at));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<CameraHistory>> localVarReturnType = new TypeReference<List<CameraHistory>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Weather camera history changes after given time. Result is in ascending order by presetId and lastModified -fields. Will be removed after 2022-11-01
   * 
   * @param after Return changes int the history after given time. Given time must be within 24 hours. (required)
   * @param id Camera or preset id(s) (optional
   * @return CameraHistoryChanges
   * @throws ApiException if fails to make API call
   */
  public CameraHistoryChanges getCameraOrPresetHistoryChanges1(OffsetDateTime after, List<String> id) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'after' is set
    if (after == null) {
      throw new ApiException(400, "Missing the required parameter 'after' when calling getCameraOrPresetHistoryChanges1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v2/data/camera-history/changes";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "id", id));
    localVarQueryParams.addAll(apiClient.parameterToPair("after", after));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<CameraHistoryChanges> localVarReturnType = new TypeReference<CameraHistoryChanges>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Find weather camera history presences
   * History presence tells if history exists for given time interval.
   * @param id Camera or preset id (optional)
   * @param from Return history presence from given date time onwards. If the start time is not given then value of now - 24h is used. (optional)
   * @param to Return history presence ending to given date time. If the end time is not given then now is used. (optional)
   * @return CameraHistoryPresences
   * @throws ApiException if fails to make API call
   */
  public CameraHistoryPresences getCameraOrPresetHistoryPresences1(String id, OffsetDateTime from, OffsetDateTime to) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v2/data/camera-history/presences";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("id", id));
    localVarQueryParams.addAll(apiClient.parameterToPair("from", from));
    localVarQueryParams.addAll(apiClient.parameterToPair("to", to));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<CameraHistoryPresences> localVarReturnType = new TypeReference<CameraHistoryPresences>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Road maintenance tracking data with tracking id. Will be removed after 2022-11-01
   * 
   * @param id Tracking id (required)
   * @return MaintenanceTrackingFeatureOld
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public MaintenanceTrackingFeatureOld getMaintenanceTracking1(Long id) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getMaintenanceTracking1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v2/data/maintenance/trackings/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<MaintenanceTrackingFeatureOld> localVarReturnType = new TypeReference<MaintenanceTrackingFeatureOld>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Road maintenance tracking tasks. Will be removed after 2022-11-01
   * 
   * @return List&lt;MaintenanceTrackingTaskOld&gt;
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public List<MaintenanceTrackingTaskOld> getMaintenanceTrackingTasks1() throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v2/data/maintenance/trackings/tasks";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<MaintenanceTrackingTaskOld>> localVarReturnType = new TypeReference<List<MaintenanceTrackingTaskOld>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Current data of Weather Forecast Sections V2
   * 
   * @param lastUpdated If parameter is given result will only contain update status (optional, default to false)
   * @param naturalIds List of forecast section indices (optional
   * @return ForecastSectionWeatherRoot
   * @throws ApiException if fails to make API call
   */
  public ForecastSectionWeatherRoot roadConditions3(Boolean lastUpdated, List<String> naturalIds) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v2/data/road-conditions";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("lastUpdated", lastUpdated));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "naturalIds", naturalIds));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ForecastSectionWeatherRoot> localVarReturnType = new TypeReference<ForecastSectionWeatherRoot>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Current data of Weather Forecast Sections V2 by road number
   * 
   * @param roadNumber RoadNumber to get data for (required)
   * @return ForecastSectionWeatherRoot
   * @throws ApiException if fails to make API call
   */
  public ForecastSectionWeatherRoot roadConditions4(Integer roadNumber) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'roadNumber' is set
    if (roadNumber == null) {
      throw new ApiException(400, "Missing the required parameter 'roadNumber' when calling roadConditions4");
    }
    
    // create path and map variables
    String localVarPath = "/api/v2/data/road-conditions/{roadNumber}"
      .replaceAll("\\{" + "roadNumber" + "\\}", apiClient.escapeString(roadNumber.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ForecastSectionWeatherRoot> localVarReturnType = new TypeReference<ForecastSectionWeatherRoot>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Current data of Weather Forecast Sections V2 by bounding box
   * 
   * @param minLongitude Minimum longitude. Coordinates are in WGS84 format in decimal degrees. (required)
   * @param minLatitude Minimum latitude. Coordinates are in WGS84 format in decimal degrees. (required)
   * @param maxLongitude Maximum longitude. Coordinates are in WGS84 format in decimal degrees. (required)
   * @param maxLatitude Maximum latitude. Coordinates are in WGS84 format in decimal degrees. (required)
   * @return ForecastSectionWeatherRoot
   * @throws ApiException if fails to make API call
   */
  public ForecastSectionWeatherRoot roadConditions5(Double minLongitude, Double minLatitude, Double maxLongitude, Double maxLatitude) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'minLongitude' is set
    if (minLongitude == null) {
      throw new ApiException(400, "Missing the required parameter 'minLongitude' when calling roadConditions5");
    }
    
    // verify the required parameter 'minLatitude' is set
    if (minLatitude == null) {
      throw new ApiException(400, "Missing the required parameter 'minLatitude' when calling roadConditions5");
    }
    
    // verify the required parameter 'maxLongitude' is set
    if (maxLongitude == null) {
      throw new ApiException(400, "Missing the required parameter 'maxLongitude' when calling roadConditions5");
    }
    
    // verify the required parameter 'maxLatitude' is set
    if (maxLatitude == null) {
      throw new ApiException(400, "Missing the required parameter 'maxLatitude' when calling roadConditions5");
    }
    
    // create path and map variables
    String localVarPath = "/api/v2/data/road-conditions/{minLongitude}/{minLatitude}/{maxLongitude}/{maxLatitude}"
      .replaceAll("\\{" + "minLongitude" + "\\}", apiClient.escapeString(minLongitude.toString()))
      .replaceAll("\\{" + "minLatitude" + "\\}", apiClient.escapeString(minLatitude.toString()))
      .replaceAll("\\{" + "maxLongitude" + "\\}", apiClient.escapeString(maxLongitude.toString()))
      .replaceAll("\\{" + "maxLatitude" + "\\}", apiClient.escapeString(maxLatitude.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ForecastSectionWeatherRoot> localVarReturnType = new TypeReference<ForecastSectionWeatherRoot>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * List the latest value of a variable sign. Will be removed after 2022-11-01
   * 
   * @param deviceId  (required)
   * @return VariableSignFeatureCollection
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public VariableSignFeatureCollection variableSignByPath2(String deviceId) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'deviceId' is set
    if (deviceId == null) {
      throw new ApiException(400, "Missing the required parameter 'deviceId' when calling variableSignByPath2");
    }
    
    // create path and map variables
    String localVarPath = "/api/v2/data/variable-signs/{deviceId}"
      .replaceAll("\\{" + "deviceId" + "\\}", apiClient.escapeString(deviceId.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<VariableSignFeatureCollection> localVarReturnType = new TypeReference<VariableSignFeatureCollection>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * List the history of variable sign data. Will be removed after 2022-11-01
   * 
   * @param deviceId List history data of given sign (required)
   * @return List&lt;TrafficSignHistory&gt;
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public List<TrafficSignHistory> variableSignHistory2(String deviceId) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'deviceId' is set
    if (deviceId == null) {
      throw new ApiException(400, "Missing the required parameter 'deviceId' when calling variableSignHistory2");
    }
    
    // create path and map variables
    String localVarPath = "/api/v2/data/variable-signs/history";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("deviceId", deviceId));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<TrafficSignHistory>> localVarReturnType = new TypeReference<List<TrafficSignHistory>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * List the history of variable sign data. Will be removed after 2022-11-01
   * 
   * @param deviceId  (required)
   * @return List&lt;TrafficSignHistory&gt;
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public List<TrafficSignHistory> variableSignHistoryByPath1(String deviceId) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'deviceId' is set
    if (deviceId == null) {
      throw new ApiException(400, "Missing the required parameter 'deviceId' when calling variableSignHistoryByPath1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v2/data/variable-signs/history/{deviceId}"
      .replaceAll("\\{" + "deviceId" + "\\}", apiClient.escapeString(deviceId.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<TrafficSignHistory>> localVarReturnType = new TypeReference<List<TrafficSignHistory>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * List the latest data of variable signs. Will be removed after 2022-11-01
   * 
   * @param deviceId If parameter is given list only latest value of given sign (optional)
   * @return VariableSignFeatureCollection
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public VariableSignFeatureCollection variableSigns2(String deviceId) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v2/data/variable-signs";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("deviceId", deviceId));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<VariableSignFeatureCollection> localVarReturnType = new TypeReference<VariableSignFeatureCollection>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
}
