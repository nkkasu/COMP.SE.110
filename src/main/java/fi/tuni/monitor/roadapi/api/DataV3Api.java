/*
 * Digitraffic Road API
 * [OpenAPI document](/swagger/openapi.json)   Digitraffic is a service operated by the [Fintraffic](https://www.fintraffic.fi) offering real time traffic information. Currently the service covers *road, marine and rail* traffic. More information can be found at the [Digitraffic website](https://www.digitraffic.fi/)   The service has a public Google-group [road.digitraffic.fi](https://groups.google.com/forum/#!forum/roaddigitrafficfi) for communication between developers, service administrators and Fintraffic. The discussion in the forum is mostly in Finnish, but you're welcome to communicate in English too.   ### General notes of the API * Many Digitraffic APIs use GeoJSON as data format. Definition of the GeoJSON format can be found at https://tools.ietf.org/html/rfc7946. * For dates and times [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format is used with \"Zulu\" zero offset from UTC unless otherwise specified (i.e., \"yyyy-mm-ddThh:mm:ss[.mmm]Z\"). E.g. 2019-11-01T06:30:00Z.
 *
 * The version of the OpenAPI document: 2.94.0#e017ffd@2022-10-18T07:48:28+0000
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package fi.tuni.monitor.roadapi.api;

import com.fasterxml.jackson.core.type.TypeReference;

import fi.tuni.monitor.roadapi.ApiException;
import fi.tuni.monitor.roadapi.ApiClient;
import fi.tuni.monitor.roadapi.Configuration;
import fi.tuni.monitor.roadapi.model.*;
import fi.tuni.monitor.roadapi.Pair;

import fi.tuni.monitor.roadapi.model.CameraHistory;
import fi.tuni.monitor.roadapi.model.CameraHistoryChanges;
import fi.tuni.monitor.roadapi.model.CameraHistoryPresences;
import fi.tuni.monitor.roadapi.model.D2LogicalModel;
import fi.tuni.monitor.roadapi.model.ForecastSectionWeatherRoot;
import fi.tuni.monitor.roadapi.model.MaintenanceTrackingFeatureCollectionOld;
import fi.tuni.monitor.roadapi.model.MaintenanceTrackingFeatureOld;
import fi.tuni.monitor.roadapi.model.MaintenanceTrackingLatestFeatureCollectionOld;
import fi.tuni.monitor.roadapi.model.MaintenanceTrackingTaskOld;
import java.time.OffsetDateTime;
import fi.tuni.monitor.roadapi.model.RegionGeometryFeatureCollectionV1;
import fi.tuni.monitor.roadapi.model.SituationTypeOldV1;
import fi.tuni.monitor.roadapi.model.TrafficAnnouncementFeatureCollectionOldV3;
import fi.tuni.monitor.roadapi.model.TrafficSignHistory;
import fi.tuni.monitor.roadapi.model.VariableSignFeatureCollection;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DataV3Api {
  private ApiClient apiClient;

  public DataV3Api() {
    this(Configuration.getDefaultApiClient());
  }

  public DataV3Api(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  public ApiClient getApiClient() {
    return apiClient;
  }

  public void setApiClient(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  /**
   * Traffic messages geometries for regions. Will be removed after 2022-11-01
   * 
   * @param lastUpdated If the parameter value is true, then the result will only contain update status. (optional, default to true)
   * @param effectiveDate When effectiveDate parameter is given only effective geometries on that date are returned (optional)
   * @param id Location code id. (optional
   * @return RegionGeometryFeatureCollectionV1
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public RegionGeometryFeatureCollectionV1 areaLocationRegions(Boolean lastUpdated, OffsetDateTime effectiveDate, List<Integer> id) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v3/data/traffic-messages/area-geometries";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("lastUpdated", lastUpdated));
    localVarQueryParams.addAll(apiClient.parameterToPair("effectiveDate", effectiveDate));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "id", id));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<RegionGeometryFeatureCollectionV1> localVarReturnType = new TypeReference<RegionGeometryFeatureCollectionV1>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Road maintenance tracking data latest points. Will be removed after 2022-11-01
   * 
   * @param from Return trackings which have completed after the given time (inclusive). Default is -1h from now and maximum -24h. (optional)
   * @param xMin Minimum x coordinate (longitude) Coordinates are in WGS84 format in decimal degrees. Values between 19.0 and 32.0. (optional, default to 19)
   * @param yMin Minimum y coordinate (latitude). Coordinates are in WGS84 format in decimal degrees. Values between 59.0 and 72.0. (optional, default to 59)
   * @param xMax Maximum x coordinate (longitude). Coordinates are in WGS84 format in decimal degrees. Values between 19.0 and 32.0. (optional, default to 32)
   * @param yMax Maximum y coordinate (latitude). Coordinates are in WGS84 format in decimal degrees. Values between 59.0 and 72.0. (optional, default to 72)
   * @param taskId Task ids to include. Any tracking containing one of the selected tasks will be returned. (optional
   * @return MaintenanceTrackingLatestFeatureCollectionOld
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public MaintenanceTrackingLatestFeatureCollectionOld findLatestMaintenanceTrackings(OffsetDateTime from, Double xMin, Double yMin, Double xMax, Double yMax, List<String> taskId) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v3/data/maintenance/trackings/latest";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("from", from));
    localVarQueryParams.addAll(apiClient.parameterToPair("xMin", xMin));
    localVarQueryParams.addAll(apiClient.parameterToPair("yMin", yMin));
    localVarQueryParams.addAll(apiClient.parameterToPair("xMax", xMax));
    localVarQueryParams.addAll(apiClient.parameterToPair("yMax", yMax));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "taskId", taskId));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<MaintenanceTrackingLatestFeatureCollectionOld> localVarReturnType = new TypeReference<MaintenanceTrackingLatestFeatureCollectionOld>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Road maintenance tracking data. Will be removed after 2022-11-01
   * 
   * @param from Return trackings which have completed after the given time (inclusive). Default is 24h in past and maximum interval between from and to is 24h. (optional)
   * @param to Return trackings which have completed before the given time (inclusive). Default is now and maximum interval between from and to is 24h. (optional)
   * @param xMin Minimum x coordinate (longitude) Coordinates are in WGS84 format in decimal degrees. Values between 19.0 and 32.0. (optional, default to 19)
   * @param yMin Minimum y coordinate (latitude). Coordinates are in WGS84 format in decimal degrees. Values between 59.0 and 72.0. (optional, default to 59)
   * @param xMax Maximum x coordinate (longitude). Coordinates are in WGS84 format in decimal degrees. Values between 19.0 and 32.0. (optional, default to 32)
   * @param yMax Maximum y coordinate (latitude). Coordinates are in WGS84 format in decimal degrees. Values between 59.0 and 72.0. (optional, default to 72)
   * @param taskId Task ids to include. Any tracking containing one of the selected tasks will be returned. (optional
   * @return MaintenanceTrackingFeatureCollectionOld
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public MaintenanceTrackingFeatureCollectionOld findMaintenanceTrackings(OffsetDateTime from, OffsetDateTime to, Double xMin, Double yMin, Double xMax, Double yMax, List<String> taskId) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v3/data/maintenance/trackings";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("from", from));
    localVarQueryParams.addAll(apiClient.parameterToPair("to", to));
    localVarQueryParams.addAll(apiClient.parameterToPair("xMin", xMin));
    localVarQueryParams.addAll(apiClient.parameterToPair("yMin", yMin));
    localVarQueryParams.addAll(apiClient.parameterToPair("xMax", xMax));
    localVarQueryParams.addAll(apiClient.parameterToPair("yMax", yMax));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "taskId", taskId));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<MaintenanceTrackingFeatureCollectionOld> localVarReturnType = new TypeReference<MaintenanceTrackingFeatureCollectionOld>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Weather camera history for given camera or preset
   * 
   * @param id Camera or preset id(s) (required)
   * @param at Return the latest url for the image from the history at the given date time. If the time is not given then the history of last 24h is returned. (optional)
   * @return List&lt;CameraHistory&gt;
   * @throws ApiException if fails to make API call
   */
  public List<CameraHistory> getCameraOrPresetHistory(List<String> id, OffsetDateTime at) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getCameraOrPresetHistory");
    }
    
    // create path and map variables
    String localVarPath = "/api/v3/data/camera-history/history";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "id", id));
    localVarQueryParams.addAll(apiClient.parameterToPair("at", at));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<CameraHistory>> localVarReturnType = new TypeReference<List<CameraHistory>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Weather camera history changes after given time. Result is in ascending order by presetId and lastModified -fields.
   * 
   * @param after Return changes int the history after given time. Given time must be within 24 hours. (required)
   * @param id Camera or preset id(s) (optional
   * @return CameraHistoryChanges
   * @throws ApiException if fails to make API call
   */
  public CameraHistoryChanges getCameraOrPresetHistoryChanges(OffsetDateTime after, List<String> id) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'after' is set
    if (after == null) {
      throw new ApiException(400, "Missing the required parameter 'after' when calling getCameraOrPresetHistoryChanges");
    }
    
    // create path and map variables
    String localVarPath = "/api/v3/data/camera-history/changes";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "id", id));
    localVarQueryParams.addAll(apiClient.parameterToPair("after", after));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<CameraHistoryChanges> localVarReturnType = new TypeReference<CameraHistoryChanges>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Find weather camera history presences
   * History presence tells if history exists for given time interval.
   * @param id Camera or preset id (optional)
   * @param from Return history presence from given date time onwards. If the start time is not given then value of now - 24h is used. (optional)
   * @param to Return history presence ending to given date time. If the end time is not given then now is used. (optional)
   * @return CameraHistoryPresences
   * @throws ApiException if fails to make API call
   */
  public CameraHistoryPresences getCameraOrPresetHistoryPresences(String id, OffsetDateTime from, OffsetDateTime to) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v3/data/camera-history/presences";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("id", id));
    localVarQueryParams.addAll(apiClient.parameterToPair("from", from));
    localVarQueryParams.addAll(apiClient.parameterToPair("to", to));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<CameraHistoryPresences> localVarReturnType = new TypeReference<CameraHistoryPresences>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Road maintenance tracking data with tracking id. Will be removed after 2022-11-01
   * 
   * @param id Tracking id (required)
   * @return MaintenanceTrackingFeatureOld
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public MaintenanceTrackingFeatureOld getMaintenanceTracking(Long id) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getMaintenanceTracking");
    }
    
    // create path and map variables
    String localVarPath = "/api/v3/data/maintenance/trackings/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<MaintenanceTrackingFeatureOld> localVarReturnType = new TypeReference<MaintenanceTrackingFeatureOld>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Road maintenance tracking tasks. Will be removed after 2022-11-01
   * 
   * @return List&lt;MaintenanceTrackingTaskOld&gt;
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public List<MaintenanceTrackingTaskOld> getMaintenanceTrackingTasks() throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v3/data/maintenance/trackings/tasks";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<MaintenanceTrackingTaskOld>> localVarReturnType = new TypeReference<List<MaintenanceTrackingTaskOld>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Current data of Weather Forecast Sections V2
   * 
   * @param lastUpdated If parameter is given result will only contain update status (optional, default to false)
   * @param naturalIds List of forecast section indices (optional
   * @return ForecastSectionWeatherRoot
   * @throws ApiException if fails to make API call
   */
  public ForecastSectionWeatherRoot roadConditions(Boolean lastUpdated, List<String> naturalIds) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v3/data/road-conditions";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("lastUpdated", lastUpdated));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "naturalIds", naturalIds));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ForecastSectionWeatherRoot> localVarReturnType = new TypeReference<ForecastSectionWeatherRoot>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Current data of Weather Forecast Sections V2 by road number
   * 
   * @param roadNumber RoadNumber to get data for (required)
   * @return ForecastSectionWeatherRoot
   * @throws ApiException if fails to make API call
   */
  public ForecastSectionWeatherRoot roadConditions1(Integer roadNumber) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'roadNumber' is set
    if (roadNumber == null) {
      throw new ApiException(400, "Missing the required parameter 'roadNumber' when calling roadConditions1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v3/data/road-conditions/{roadNumber}"
      .replaceAll("\\{" + "roadNumber" + "\\}", apiClient.escapeString(roadNumber.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ForecastSectionWeatherRoot> localVarReturnType = new TypeReference<ForecastSectionWeatherRoot>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Current data of Weather Forecast Sections V2 by bounding box
   * 
   * @param minLongitude Minimum longitude. Coordinates are in WGS84 format in decimal degrees. (required)
   * @param minLatitude Minimum latitude. Coordinates are in WGS84 format in decimal degrees. (required)
   * @param maxLongitude Maximum longitude. Coordinates are in WGS84 format in decimal degrees. (required)
   * @param maxLatitude Maximum latitude. Coordinates are in WGS84 format in decimal degrees. (required)
   * @return ForecastSectionWeatherRoot
   * @throws ApiException if fails to make API call
   */
  public ForecastSectionWeatherRoot roadConditions2(Double minLongitude, Double minLatitude, Double maxLongitude, Double maxLatitude) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'minLongitude' is set
    if (minLongitude == null) {
      throw new ApiException(400, "Missing the required parameter 'minLongitude' when calling roadConditions2");
    }
    
    // verify the required parameter 'minLatitude' is set
    if (minLatitude == null) {
      throw new ApiException(400, "Missing the required parameter 'minLatitude' when calling roadConditions2");
    }
    
    // verify the required parameter 'maxLongitude' is set
    if (maxLongitude == null) {
      throw new ApiException(400, "Missing the required parameter 'maxLongitude' when calling roadConditions2");
    }
    
    // verify the required parameter 'maxLatitude' is set
    if (maxLatitude == null) {
      throw new ApiException(400, "Missing the required parameter 'maxLatitude' when calling roadConditions2");
    }
    
    // create path and map variables
    String localVarPath = "/api/v3/data/road-conditions/{minLongitude}/{minLatitude}/{maxLongitude}/{maxLatitude}"
      .replaceAll("\\{" + "minLongitude" + "\\}", apiClient.escapeString(minLongitude.toString()))
      .replaceAll("\\{" + "minLatitude" + "\\}", apiClient.escapeString(minLatitude.toString()))
      .replaceAll("\\{" + "maxLongitude" + "\\}", apiClient.escapeString(maxLongitude.toString()))
      .replaceAll("\\{" + "maxLatitude" + "\\}", apiClient.escapeString(maxLatitude.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ForecastSectionWeatherRoot> localVarReturnType = new TypeReference<ForecastSectionWeatherRoot>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Active traffic messages as Datex2. Will be removed after 2022-11-01
   * 
   * @param inactiveHours Return traffic messages from given amount of hours in the past. (optional, default to 0)
   * @param situationType Situation type. (optional
   * @return D2LogicalModel
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public D2LogicalModel trafficMessageDatex2(Integer inactiveHours, List<SituationTypeOldV1> situationType) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v3/data/traffic-messages/datex2";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("inactiveHours", inactiveHours));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "situationType", situationType));

    
    
    
    final String[] localVarAccepts = {
      "application/xml;charset=UTF-8", "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<D2LogicalModel> localVarReturnType = new TypeReference<D2LogicalModel>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Traffic messages history by situation as Datex2. Will be removed after 2022-11-01
   * 
   * @param situationId Situation id. (required)
   * @param latest If the parameter value is true, then only the latest message will be returned (optional, default to false)
   * @return D2LogicalModel
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public D2LogicalModel trafficMessageDatex2BySituationId(String situationId, Boolean latest) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'situationId' is set
    if (situationId == null) {
      throw new ApiException(400, "Missing the required parameter 'situationId' when calling trafficMessageDatex2BySituationId");
    }
    
    // create path and map variables
    String localVarPath = "/api/v3/data/traffic-messages/datex2/{situationId}"
      .replaceAll("\\{" + "situationId" + "\\}", apiClient.escapeString(situationId.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("latest", latest));

    
    
    
    final String[] localVarAccepts = {
      "application/xml;charset=UTF-8", "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<D2LogicalModel> localVarReturnType = new TypeReference<D2LogicalModel>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Active traffic messages as simple JSON. Will be removed after 2022-11-01
   * 
   * @param inactiveHours Return traffic messages from given amount of hours in the past. (optional, default to 0)
   * @param includeAreaGeometry If the parameter value is false, then the GeoJson geometry will be empty for announcements with area locations. Geometries for areas can be fetched from Traffic messages geometries for regions -api (optional, default to false)
   * @param situationType Situation type. (optional
   * @return TrafficAnnouncementFeatureCollectionOldV3
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public TrafficAnnouncementFeatureCollectionOldV3 trafficMessageSimple(Integer inactiveHours, Boolean includeAreaGeometry, List<SituationTypeOldV1> situationType) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v3/data/traffic-messages/simple";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("inactiveHours", inactiveHours));
    localVarQueryParams.addAll(apiClient.parameterToPair("includeAreaGeometry", includeAreaGeometry));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "situationType", situationType));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<TrafficAnnouncementFeatureCollectionOldV3> localVarReturnType = new TypeReference<TrafficAnnouncementFeatureCollectionOldV3>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Traffic messages history by situation id as simple JSON. Will be removed after 2022-11-01
   * 
   * @param situationId Situation id. (required)
   * @param includeAreaGeometry If the parameter value is false, then the GeoJson geometry will be empty for announcements with area locations. Geometries for areas can be fetched from Traffic messages geometries for regions -api (optional, default to false)
   * @param latest If the parameter value is true, then only the latest message will be returned (optional, default to false)
   * @return TrafficAnnouncementFeatureCollectionOldV3
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public TrafficAnnouncementFeatureCollectionOldV3 trafficMessageSimpleBySituationId(String situationId, Boolean includeAreaGeometry, Boolean latest) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'situationId' is set
    if (situationId == null) {
      throw new ApiException(400, "Missing the required parameter 'situationId' when calling trafficMessageSimpleBySituationId");
    }
    
    // create path and map variables
    String localVarPath = "/api/v3/data/traffic-messages/simple/{situationId}"
      .replaceAll("\\{" + "situationId" + "\\}", apiClient.escapeString(situationId.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("includeAreaGeometry", includeAreaGeometry));
    localVarQueryParams.addAll(apiClient.parameterToPair("latest", latest));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<TrafficAnnouncementFeatureCollectionOldV3> localVarReturnType = new TypeReference<TrafficAnnouncementFeatureCollectionOldV3>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * List the latest value of a variable sign. Will be removed after 2022-11-01
   * 
   * @param deviceId  (required)
   * @return VariableSignFeatureCollection
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public VariableSignFeatureCollection variableSignByPath1(String deviceId) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'deviceId' is set
    if (deviceId == null) {
      throw new ApiException(400, "Missing the required parameter 'deviceId' when calling variableSignByPath1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v3/data/variable-signs/{deviceId}"
      .replaceAll("\\{" + "deviceId" + "\\}", apiClient.escapeString(deviceId.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<VariableSignFeatureCollection> localVarReturnType = new TypeReference<VariableSignFeatureCollection>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * List the history of variable sign data. Will be removed after 2022-11-01
   * 
   * @param deviceId List history data of given sign (required)
   * @return List&lt;TrafficSignHistory&gt;
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public List<TrafficSignHistory> variableSignHistory1(String deviceId) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'deviceId' is set
    if (deviceId == null) {
      throw new ApiException(400, "Missing the required parameter 'deviceId' when calling variableSignHistory1");
    }
    
    // create path and map variables
    String localVarPath = "/api/v3/data/variable-signs/history";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("deviceId", deviceId));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<TrafficSignHistory>> localVarReturnType = new TypeReference<List<TrafficSignHistory>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * List the history of variable sign data. Will be removed after 2022-11-01
   * 
   * @param deviceId  (required)
   * @return List&lt;TrafficSignHistory&gt;
   * @throws ApiException if fails to make API call
   */
  public List<TrafficSignHistory> variableSignHistoryByPath(String deviceId) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'deviceId' is set
    if (deviceId == null) {
      throw new ApiException(400, "Missing the required parameter 'deviceId' when calling variableSignHistoryByPath");
    }
    
    // create path and map variables
    String localVarPath = "/api/v3/data/variable-signs/history/{deviceId}"
      .replaceAll("\\{" + "deviceId" + "\\}", apiClient.escapeString(deviceId.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<List<TrafficSignHistory>> localVarReturnType = new TypeReference<List<TrafficSignHistory>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * List the latest data of variable signs. Will be removed after 2022-11-01
   * 
   * @param deviceId If parameter is given list only latest value of given sign (optional)
   * @return VariableSignFeatureCollection
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public VariableSignFeatureCollection variableSigns1(String deviceId) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v3/data/variable-signs";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("deviceId", deviceId));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<VariableSignFeatureCollection> localVarReturnType = new TypeReference<VariableSignFeatureCollection>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
}
