/*
 * Digitraffic Road API
 * [OpenAPI document](/swagger/openapi.json)   Digitraffic is a service operated by the [Fintraffic](https://www.fintraffic.fi) offering real time traffic information. Currently the service covers *road, marine and rail* traffic. More information can be found at the [Digitraffic website](https://www.digitraffic.fi/)   The service has a public Google-group [road.digitraffic.fi](https://groups.google.com/forum/#!forum/roaddigitrafficfi) for communication between developers, service administrators and Fintraffic. The discussion in the forum is mostly in Finnish, but you're welcome to communicate in English too.   ### General notes of the API * Many Digitraffic APIs use GeoJSON as data format. Definition of the GeoJSON format can be found at https://tools.ietf.org/html/rfc7946. * For dates and times [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format is used with \"Zulu\" zero offset from UTC unless otherwise specified (i.e., \"yyyy-mm-ddThh:mm:ss[.mmm]Z\"). E.g. 2019-11-01T06:30:00Z.
 *
 * The version of the OpenAPI document: 2.94.0#e017ffd@2022-10-18T07:48:28+0000
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package fi.tuni.monitor.roadapi.api;

import com.fasterxml.jackson.core.type.TypeReference;

import fi.tuni.monitor.roadapi.ApiException;
import fi.tuni.monitor.roadapi.ApiClient;
import fi.tuni.monitor.roadapi.Configuration;
import fi.tuni.monitor.roadapi.model.*;
import fi.tuni.monitor.roadapi.Pair;

import fi.tuni.monitor.roadapi.model.D2LogicalModel;
import java.time.OffsetDateTime;
import fi.tuni.monitor.roadapi.model.RegionGeometryFeatureCollectionV1;
import fi.tuni.monitor.roadapi.model.SituationTypeV1;
import fi.tuni.monitor.roadapi.model.TrafficAnnouncementFeatureCollectionV1;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TrafficMessageApi {
  private ApiClient apiClient;

  public TrafficMessageApi() {
    this(Configuration.getDefaultApiClient());
  }

  public TrafficMessageApi(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  public ApiClient getApiClient() {
    return apiClient;
  }

  public void setApiClient(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  /**
   * Traffic messages geometries for regions
   * 
   * @param lastUpdated If the parameter value is true, then the result will only contain update status. (optional, default to true)
   * @param includeGeometry If the parameter value is false, then the result will not contain also geometries. (optional, default to false)
   * @param effectiveDate When effectiveDate parameter is given only effective geometries on that date are returned (optional)
   * @return RegionGeometryFeatureCollectionV1
   * @throws ApiException if fails to make API call
   */
  public RegionGeometryFeatureCollectionV1 areaLocationRegions1(Boolean lastUpdated, Boolean includeGeometry, OffsetDateTime effectiveDate) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/traffic-message/v1/area-geometries";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("lastUpdated", lastUpdated));
    localVarQueryParams.addAll(apiClient.parameterToPair("includeGeometry", includeGeometry));
    localVarQueryParams.addAll(apiClient.parameterToPair("effectiveDate", effectiveDate));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<RegionGeometryFeatureCollectionV1> localVarReturnType = new TypeReference<RegionGeometryFeatureCollectionV1>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Traffic messages geometries for regions
   * 
   * @param locationCode Location code id (required)
   * @param lastUpdated If the parameter value is true, then the result will only contain update status. (optional, default to true)
   * @param includeGeometry If the parameter value is false, then the result will not contain also geometries. (optional, default to false)
   * @param effectiveDate When effectiveDate parameter is given only effective geometries on that date are returned (optional)
   * @return RegionGeometryFeatureCollectionV1
   * @throws ApiException if fails to make API call
   */
  public RegionGeometryFeatureCollectionV1 areaLocationRegions2(Integer locationCode, Boolean lastUpdated, Boolean includeGeometry, OffsetDateTime effectiveDate) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'locationCode' is set
    if (locationCode == null) {
      throw new ApiException(400, "Missing the required parameter 'locationCode' when calling areaLocationRegions2");
    }
    
    // create path and map variables
    String localVarPath = "/api/traffic-message/v1/area-geometries/{locationCode}"
      .replaceAll("\\{" + "locationCode" + "\\}", apiClient.escapeString(locationCode.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("lastUpdated", lastUpdated));
    localVarQueryParams.addAll(apiClient.parameterToPair("includeGeometry", includeGeometry));
    localVarQueryParams.addAll(apiClient.parameterToPair("effectiveDate", effectiveDate));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<RegionGeometryFeatureCollectionV1> localVarReturnType = new TypeReference<RegionGeometryFeatureCollectionV1>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Active traffic messages as Datex2
   * 
   * @param situationType Situation type. (required)
   * @param inactiveHours Return traffic messages from given amount of hours in the past. (optional, default to 0)
   * @return D2LogicalModel
   * @throws ApiException if fails to make API call
   */
  public D2LogicalModel trafficMessageDatex21(List<SituationTypeV1> situationType, Integer inactiveHours) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'situationType' is set
    if (situationType == null) {
      throw new ApiException(400, "Missing the required parameter 'situationType' when calling trafficMessageDatex21");
    }
    
    // create path and map variables
    String localVarPath = "/api/traffic-message/v1/messages.datex2";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("inactiveHours", inactiveHours));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "situationType", situationType));

    
    
    
    final String[] localVarAccepts = {
      "application/xml;charset=UTF-8", "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<D2LogicalModel> localVarReturnType = new TypeReference<D2LogicalModel>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Traffic messages by situationId as Datex2
   * 
   * @param situationId Situation id. (required)
   * @param latest If the parameter value is true, then only the latest message will be returned otherwise all messages are returned (optional, default to true)
   * @return D2LogicalModel
   * @throws ApiException if fails to make API call
   */
  public D2LogicalModel trafficMessageDatex2BySituationId1(String situationId, Boolean latest) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'situationId' is set
    if (situationId == null) {
      throw new ApiException(400, "Missing the required parameter 'situationId' when calling trafficMessageDatex2BySituationId1");
    }
    
    // create path and map variables
    String localVarPath = "/api/traffic-message/v1/messages/{situationId}.datex2"
      .replaceAll("\\{" + "situationId" + "\\}", apiClient.escapeString(situationId.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("latest", latest));

    
    
    
    final String[] localVarAccepts = {
      "application/xml;charset=UTF-8", "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<D2LogicalModel> localVarReturnType = new TypeReference<D2LogicalModel>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Active traffic messages as simple JSON
   * 
   * @param situationType Situation type. (required)
   * @param inactiveHours Return traffic messages from given amount of hours in the past. (optional, default to 0)
   * @param includeAreaGeometry If the parameter value is false, then the GeoJson geometry will be empty for announcements with area locations. Geometries for areas can be fetched from Traffic messages geometries for regions -api (optional, default to false)
   * @return TrafficAnnouncementFeatureCollectionV1
   * @throws ApiException if fails to make API call
   */
  public TrafficAnnouncementFeatureCollectionV1 trafficMessageSimple1(List<SituationTypeV1> situationType, Integer inactiveHours, Boolean includeAreaGeometry) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'situationType' is set
    if (situationType == null) {
      throw new ApiException(400, "Missing the required parameter 'situationType' when calling trafficMessageSimple1");
    }
    
    // create path and map variables
    String localVarPath = "/api/traffic-message/v1/messages";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("inactiveHours", inactiveHours));
    localVarQueryParams.addAll(apiClient.parameterToPair("includeAreaGeometry", includeAreaGeometry));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "situationType", situationType));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<TrafficAnnouncementFeatureCollectionV1> localVarReturnType = new TypeReference<TrafficAnnouncementFeatureCollectionV1>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
  /**
   * Traffic messages history by situation id as simple JSON
   * 
   * @param situationId Situation id. (required)
   * @param includeAreaGeometry If the parameter value is false, then the GeoJson geometry will be empty for announcements with area locations. Geometries for areas can be fetched from Traffic messages geometries for regions -api (optional, default to false)
   * @param latest If the parameter value is true, then only the latest message will be returned (optional, default to false)
   * @return TrafficAnnouncementFeatureCollectionV1
   * @throws ApiException if fails to make API call
   */
  public TrafficAnnouncementFeatureCollectionV1 trafficMessageSimpleBySituationId1(String situationId, Boolean includeAreaGeometry, Boolean latest) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'situationId' is set
    if (situationId == null) {
      throw new ApiException(400, "Missing the required parameter 'situationId' when calling trafficMessageSimpleBySituationId1");
    }
    
    // create path and map variables
    String localVarPath = "/api/traffic-message/v1/messages/{situationId}"
      .replaceAll("\\{" + "situationId" + "\\}", apiClient.escapeString(situationId.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("includeAreaGeometry", includeAreaGeometry));
    localVarQueryParams.addAll(apiClient.parameterToPair("latest", latest));

    
    
    
    final String[] localVarAccepts = {
      "application/json;charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<TrafficAnnouncementFeatureCollectionV1> localVarReturnType = new TypeReference<TrafficAnnouncementFeatureCollectionV1>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }
}
